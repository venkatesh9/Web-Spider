#lang racket
(require racket/file)

(provide bring-links)

;(define out (open-output-file "search-results.txt"  #:mode 'binary #:exists 'replace))
(define (new-file path) (filter smallcheck (file->lines path)))

(define (smallcheck strng)
  (let ((lst (string->list strng)))
    (define (helper x)
      (cond ((null? x) #t)
            ((member (car x) lst) (helper (cdr x)))
            (else #f)))
    (helper '(#\a #\h #\r #\e #\f #\t #\p))))

(define (extract-all lst accumulator)
  (define (extract strng )
    (let ((lst (string->list strng)))
      (define (get-links lst)
        (let ((nlst (drop lst 9)))
          (define (helper n l)
            (cond ((or (null? l) (equal? (car l) #\")) (cons (list->string (take nlst n)) n))
                  (else (helper (+ n 1) (cdr l)))))
          (helper 0 nlst)))
      (define (helper lst acc)
        (cond ((null? lst) acc)
              ((equal? (car lst) #\<)
               (if (>= (length lst) 16) (cond ((equal? (take lst 13) '(#\< #\a #\space #\h #\r #\e #\f #\= #\" #\h #\t #\t #\p))
                                               (helper (drop lst (cdr (get-links lst))) (cons (car (get-links lst)) acc)))
                                              (else (helper (cdr lst) acc))) acc))
              (else (helper (cdr lst) acc))))
      (helper lst '())))
  (let ((n (length lst)))
    (cond ((= n 0) accumulator)
          (else  (extract-all (cdr lst) (append (extract (car lst)) accumulator))))))

(define (final-search lst)
  (define (helper lst accumulator)
    (cond ((null?  lst) accumulator)
          (else (let ((mem (car lst))
                      (remaining (cdr lst)))
                  (helper (filter (lambda (x) (not (equal? x mem))) remaining) (cons mem accumulator))))))
  (helper lst '()))

(define (bring-links a)
  (final-search (extract-all (new-file a) '())))
